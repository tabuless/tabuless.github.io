[{"categories":["知识图谱","基本模型"],"content":"GAT1 graph attention network，用于解决图结构数据的分类问题。主要思想是通过计算与其相邻的节点的关系（self-attention机制）计算每个节点的表示方法。 attention机制的优点： 不同相邻节点对可以并行操作 通过不同的权重表示不同的度（degree）的节点 inductive learning inductive:如果训练数据不包括测试集，如经典样本独立的supervised learning transductive:如果训练数据包括测试集（无标注），如样本间有连接的LPA算法 ","date":"2022-03-07","objectID":"/gat_gatv2/:1:0","tags":["图神经网络"],"title":"GAT\u0026GATv2","uri":"/gat_gatv2/"},{"categories":["知识图谱","基本模型"],"content":"graph attention layer GAT每层成为graph attention layer： 单层输入、输出为节点的特征（feature）： $$ 输入：\\mathbf{h} = { \\overrightarrow{h_1}, \\overrightarrow{h_2}, \\dots, \\overrightarrow{h_N} }, \\overrightarrow{h_i} \\in \\mathbb{R}^F\\ 输出：\\mathbf{h'} = { \\overrightarrow{h'_1}, \\overrightarrow{h'_2}, \\dots, \\overrightarrow{h'_N} },\\overrightarrow{h'_i} \\in \\mathbb{R}^{F'} $$ F/F' 每个节点的输入/输出特征 h/h' 输入/输出节点的特征集合 N 节点个数 attention的计算 首先计算attention系数： $$ e_{ij} = a(\\mathbf{W} \\overrightarrow{h_i}, \\mathbf{W} \\overrightarrow{h_j})，j\\in \\mathcal{N}_i $$ 符号 含义 $e_{ij}$ 节点i与j之间的attention系数（attention coefficient） a $\\mathbb{R}^{F'}\\times \\mathbb{R}^{F'}\\rightarrow \\mathbb{R}$ 的attention机制，表示节点j对i的重要性，最简单的a是一个单层全连接神经网络（FFN） $\\mathcal{N}_i$ i的相邻节点 $\\mathcal{N}_i$是attention引入图的一个核心概念，因为不相邻的节点没有直接联系 论文中论文中使用$\\overrightarrow{a}\\in \\mathbb{R}^{2F'}$，并且应用LeakyReLU： $$ e_{ij} = \\text{LeakyReLU} \\Big( \\overrightarrow{\\mathbf{a}}^\\top \\Big[\\mathbf{W} \\overrightarrow{h_i}|| \\mathbf{W} \\overrightarrow{h_j} \\Big] \\Big) $$ 其中||是concat操作。 为了让attention 系数在不同节点之间有可比较性，进行一次softmax： $$ \\alpha_{ij} = \\text{softmax}j(e{ij}) = \\frac{\\exp(e_{ij})}{\\sum_{j \\in \\mathcal{N}i} \\exp(e{ij})} $$ 上述的$\\alpha_{ij}$指的就是节点i与节点j之间的attention。 加入激活函数 对于多头的注意力机制，假如有$K$个头，则第$k$头的输出$\\overrightarrow{h'^k_i}$为： $$ \\overrightarrow{h'^k_i} =\\sigma \\Big (\\sum_{j \\in \\mathcal{N}i} \\alpha^k{ij} \\mathbf{W}^k \\overrightarrow{h_j} \\Big ) $$ 最后通过一个concat操作得到最终的多头attention的单层输出： $$ \\overrightarrow{h'i} = \\Bigg\\Vert{k=1}^{K} \\overrightarrow{h'^k_i} $$ ","date":"2022-03-07","objectID":"/gat_gatv2/:1:1","tags":["图神经网络"],"title":"GAT\u0026GATv2","uri":"/gat_gatv2/"},{"categories":["知识图谱","基本模型"],"content":"GAT最后一层 如果在最后一层的话multi-head的concat操作不再敏感，一般不会concat，而是对每个head取平均，把非线性层（softmax或者sigmoid）放在最后进行操作： $$ \\overrightarrow{h_i'} =\\sigma \\Big (\\frac{1}{K}\\sum_{k=1}^{K}\\sum_{j \\in \\mathcal{N}i} \\alpha^k{ij} \\mathbf{W}^k \\overrightarrow{h_j} \\Big ) $$ ","date":"2022-03-07","objectID":"/gat_gatv2/:1:2","tags":["图神经网络"],"title":"GAT\u0026GATv2","uri":"/gat_gatv2/"},{"categories":["知识图谱","基本模型"],"content":"GAT和GCN的比较 计算高效，所有的相邻节点之间的attention可以并行计算 给不同相邻节点间赋值不同的重要性 代码示例：https://nn.labml.ai/graphs/gat/index.html ","date":"2022-03-07","objectID":"/gat_gatv2/:1:3","tags":["图神经网络"],"title":"GAT\u0026GATv2","uri":"/gat_gatv2/"},{"categories":["知识图谱","基本模型"],"content":"GATv22 在GAT中，每个节点通过使用自己的representation作为query，根据其邻居节点更新其representation。通过让每个节点计算邻居节点之间的加权平均得到最相关的节点，产生了很多典型的average-pooling和max-pooling。 但是GATv2的作者认为GAT没有真正计算真正的注意力，GAT的注意力被定义为静态注意力（static attention），真正的注意力被他们称之为动态注意力（dynamic attention）。 通过修改GAT中的操作顺序，GATv2实现了一个通用的近似注意函数，因此严格来说比GAT更强大。 静态/动态注意力（static/dynamic attention） GAT中，对于任意的节点（query），attention函数是关于邻接节点（key）单调（monotonic）的：对于一组keys，如果不同的query对这组keys进行attention，得到的attention分数排名不变，那么这个attention函数就是静态的。如下图所示。 静态注意力的定义：已知一个key的集合$\\mathbb{K}={k_1,k_2,…,k_n}\\subset \\mathbb{R}^d$与query集合$\\mathbb{Q}={q_1,q_2,…,q_m}\\subset \\mathbb{R}^d$，对于一个打分函数族$\\mathcal{F}\\subseteq (\\mathbb{R}^d\\times\\mathbb{R}^d \\rightarrow \\mathbb{R})$，如果对于$\\forall f\\in\\mathcal{F}$，存在一个“最高分数”的key $j_f\\in [n]$，使得对每个query $i\\in [m]$与key $j\\in [n]$有：$f ( q { i } , k { j_f } ) \\geq f ( q { i } , k { j } )$恒成立，则称该函数族为$\\mathbb{K}$与$\\mathbb{Q}$的静态注意力的函数族。 动态注意力的定义：已知一个key的集合$\\mathbb{K}={k_1,k_2,…,k_n}\\subset \\mathbb{R}^d$与query集合$\\mathbb{Q}={q_1,q_2,…,q_m}\\subset \\mathbb{R}^d$，对于一个打分函数族$\\mathcal{F}\\subseteq (\\mathbb{R}^d\\times\\mathbb{R}^d \\rightarrow \\mathbb{R})$，如果对任何的映射$\\varphi : [ m ] \\rightarrow [ n ]$存在$f\\in\\mathcal{F}$使得对任何的query $i\\in [m]$与key $j_{\\neq \\varphi(i)}\\in [n]$有$f ( q_ { i } , k {\\varphi (i)} ) \\geq f ( q { i } , k _ { j } )$，则称该函数族为$\\mathbb{K}$与$\\mathbb{Q}$的动态注意力的函数族。 GAT是静态注意力的证明比较简单，大致思路是将计算$e_{ij}$的$\\overrightarrow{a}$进行分块：$\\overrightarrow{a}=[a_1||a_2]$，则有： $$ e_{ij} = \\text{LeakyReLU} \\Big( \\overrightarrow{\\mathbf{a}}^\\top \\Big[\\mathbf{W} \\overrightarrow{h_i}|| \\mathbf{W} \\overrightarrow{h_j} \\Big] \\Big)\\ =\\text{LeakyReLU} \\Big( [a_1||a_2]^\\top \\Big[\\mathbf{W} \\overrightarrow{h_i}|| \\mathbf{W} \\overrightarrow{h_j} \\Big] \\Big)\\ =\\text{LeakyReLU} \\Big( [a_1^\\top \\mathbf{W} h_i+ a_2^\\top \\mathbf{W} h_j \\Big) $$ 证明得到的结论是：$s_j=a_2^\\top \\mathbf{W} h_j$对于任何的query节点（$h_i$）来说，最大值都是不变的，$s_i=a_1^\\top \\mathbf{W} h_i$这一项仅仅表征了图像的陡峭程度（如图figure 1a）。 GATv2的动态注意力 GAT之所以会是静态的原因在于$W和a$是连乘的，会坍缩为一个先行层，进行如下的改进： | GAT | $e(h_i,h_j) = \\text{LeakyReLU} \\Big( \\overrightarrow{\\mathbf{a}}^\\top \\Big[\\mathbf{W} \\overrightarrow{h_i}||\\mathbf{W} \\overrightarrow{h_j} \\Big] \\Big)$ | | —– | ———————————————————— | | GATv2 | $e(h_i,h_j) = \\overrightarrow{\\mathbf{a}}^\\top\\text{LeakyReLU} \\Big(\\mathbf{W}\\Big[ \\overrightarrow{h_i}||\\overrightarrow{h_j} \\Big] \\Big)$ | 如何选择GAT与GATv2 一般来说很难预先知道两个模型哪个更好，理论上更差的模型可能实际上表现更好，因为可能会产生过拟合等问题，因此作者认为节点之间的交互越复杂那么理论上GATv2会有更好的效果：如果某个问题有全局排序那么GAT可能会好一点，如果不同节点有不同的排序那么GATv2会更好一点。 GAT的作者也是在Twitter上说明了GAT是针对容易过拟合的数据集进行设计的（如cora，citeseer等）。 Veličković P, Cucurull G, Casanova A, et al. Graph Attention Networks[C]//International Conference on Learning Representations. 2018. ↩︎ Brody S, Alon U, Yahav E. How attentive are graph attention networks?[J]. arXiv preprint arXiv:2105.14491, 2021. ↩︎ ","date":"2022-03-07","objectID":"/gat_gatv2/:2:0","tags":["图神经网络"],"title":"GAT\u0026GATv2","uri":"/gat_gatv2/"},{"categories":["知识图谱","综述"],"content":"时序信息嵌入 ","date":"2022-01-21","objectID":"/%E6%97%B6%E5%BA%8F%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BB%BC%E8%BF%B0/:1:0","tags":["知识图谱"],"title":"时序知识图谱综述","uri":"/%E6%97%B6%E5%BA%8F%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BB%BC%E8%BF%B0/"},{"categories":["知识图谱","综述"],"content":"transE的几个变形1$^,$2$^,$3 HyTE HyTE主要思想： $$ P _ { \\tau } ( e _ { h } ) = e _ { h } - ( w _ { \\tau } ^ { T } e _ { h } ) w _ { \\tau }\\\\ P _ { \\tau } ( e _ { t } ) = e _ { t } - ( w _ { \\tau } ^ { T } e _ { t } ) w _ { \\tau }\\\\ P _ { \\tau } ( e _ { r } ) = e _ { r } - ( w _ { \\tau } ^ { T } e _ { r } ) w _ { \\tau }\\\\ f _ { \\tau } ( h , r , t ) = | | P _ { T } ( e _ { h } ) + P _ { \\tau } ( e _ { r } ) - P _ { \\tau } ( e _ { t } ) | | _ { l _ { 1 } / l _ { 2 } }\\\\ L = \\sum _ { r \\in [ T ] } \\sum _ { x \\in D_{\\tau}^{+}} \\sum _ { y \\in D_{\\tau}^{-}} max( 0 , f _ { \\tau ( x ) }- f _ { \\tau } ( y )+ \\gamma) $$ 与以前的时间敏感的KG嵌入方法相比，HyTE直接在训练的时候嵌入中编码时间信息。这使我们能够预测以前未考虑范围的KG事件的时间范围。 TA_transE $$ f_{\\tau}=| | h + r _ { t e m p } - t | | _ { 2 } $$ 一个例子： h r t 时间 原文关系 Lawyer/Attorney (Turkey) Complain officially Citizen (Turkey) 2014-06-24 编码方式 Lawyer/Attorney (Turkey) $p_{seq}$:[Complain officially,2y,0y,1y,4y,06m,2d,4d] Citizen (Turkey) 编码 5890 $p_{seq}的编码$:[138, 2, 0, 1, 4, 15, 24, 26] 280 如果有诸如since或者until之类的词语，则编码如下： 最后会拿上述的编码进行嵌入与训练。 上述的关系也称为带有时序信息的谓词（predicate sequence，$p_{seq}$）。 ","date":"2022-01-21","objectID":"/%E6%97%B6%E5%BA%8F%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BB%BC%E8%BF%B0/:1:1","tags":["知识图谱"],"title":"时序知识图谱综述","uri":"/%E6%97%B6%E5%BA%8F%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BB%BC%E8%BF%B0/"},{"categories":["知识图谱","综述"],"content":"评价指标mean rank 与filtered mean rank 假设整个知识库中一共有n个实体，那么评价过程如下2： 将一个正确的三元组a中的头实体或者尾实体，依次替换为整个知识库中的所有其它实体，也就是会产生n个三元组。 分别对上述n个三元组计算其能量值，在transE中，就是计算h+r-t的值。这样可以得到n个能量值，分别对应上述n个三元组。 对上述n个能量值进行升序排序。 记录三元组a的能量值排序后的序号。 对所有的正确的三元组重复上述过程。 每个正确三元组的能量值排序后的序号求平均，得到的值我们称为Mean Rank。 计算正确三元组的能量排序后的序号小于10的比例，得到的值我们称为Hits@10。 上述就是评价的过程，共有两个指标：Mean Rank和Hits@10。其中Mean Rank越小越好，Hits@10越大越好。 改进: 但是上述过程存在一个不合理的地方：在将一个正确的三元组a的头或者尾实体替换成其它实体之后得到的这个三元组也有可能是正确的，在计算每个三元组的能量并排序之后，这类正确的三元组的能量有可能排在三元组a的前面。但是上面所说的基本评价过程并没有考虑这点。因此我们把上述基本评价过程得到的结果称为Raw Mean Rank和Raw Hits@10，把改进方法得到的结果称为Filtered Mean Rank和Filtered Hits@10。 为了更好的评价embedding的质量，我们对上述方法进行改进。 将一个正确的三元组a中的头实体或者尾实体，依次替换为整个知识库中的所有其它实体，也就是会产生n个三元组。 分别对上述n个三元组计算其能量值，在transE中，就是计算h+r-t的值。这样可以得到n个能量值，分别对应上述n个三元组。 对上述n个能量值进行升序排序。 记录三元组a的能量值排序后的序号k。 如果前k-1个能量对应的三元组中有m个三元组也是正确的，那么三元组a的序号改为k-m。 对所有的正确的三元组重复上述过程。 每个正确三元组的能量值排序后的序号求平均，得到的值我们称为Filtered Mean Rank。 计算正确三元组的能量排序后的序号小于10的比例，得到的值我们称为Filtered Hits@10。 Tingsong Jiang, Tianyu Liu, Tao Ge, Lei Sha, Sujian Li, Baobao Chang, and Zhifang Sui. 2016. Encoding temporal information for time-aware link prediction.In Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pages 2350–2354. Association for Computational Linguistics. ↩︎ https://xiangrongzeng.github.io/knowledge%20graph/transE-evaluation.html ↩︎ A. Garc´ıa-Dur´an, S. Dumanˇci´c, and M. Niepert, “Learning sequence encoders for temporal knowledge graph completion,” in EMNLP, 2018,pp. 4816–4821. ↩︎ ","date":"2022-01-21","objectID":"/%E6%97%B6%E5%BA%8F%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BB%BC%E8%BF%B0/:1:2","tags":["知识图谱"],"title":"时序知识图谱综述","uri":"/%E6%97%B6%E5%BA%8F%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%BB%BC%E8%BF%B0/"},{"categories":["虚拟化"],"content":"kata_container架构 kata基于英特尔虚拟化技术（VT），想要解决容器内的安全问题。 使用Intel VT，能够将容器作为轻量级虚拟机启动，从而提供了与流行的容器环境（如Kubernetes 和Docker ）交互的runtime替代工具。 对于每个kata容器，都会运行在一个VM上，单独享有内核与namespace。所以系统调用是与主机隔离的。sysfs与procfs也是隔离的1 Runtime 组件Runtime 是Kata Containers 运行时， 负责处 理OCI runtime 的所有命令并启动kata-shim 实例。它 大量利用virtcontainers 软件包，该软件包提供了一套通 用，与运行时规范无关，硬件虚拟化的容器库，负责创建 在Linux 主机上运行的硬件虚拟化Linux 容器。该运行时 与OCI 兼容，CRI-O 以及Containerd 兼容，从而使其可 以分别与Docker 和Kubernetes 无缝地工作。安装kata runtime 时可在路径/usr/share/defaults/kata-containers/ configuration.toml 配置文件中定义hypervisor 路径、 guest kernel 以及mini-OS 映像。 Agent Agent 是运行在微虚机中的一个运行时代理组件，负 责虚机内的容器及容器内部进程的生命周期管理，替运行 在宿主机上的runtime 实际管理运行在虚机上的容器环境。 Agent 的最小执行单元是sandbox，一个sandbox 对应一 系列的命名空间（NS，UTS，IPC，PID）。Kata 容器支 持一个虚机内运行多个容器，由agent 管理一个虚机内的 多个容器及内部进程。Agent 重用了许多runC 代码，利 用libcontainer 管理容器生命周期，并通过gRPC 协议实 现与其他Kata 组件的通信。 Proxy 组件Proxy 负责Kata 容器代理服务， 代理agent 与shim、runtime 之间的通信，负责路由shim 到对应的 agent。默认由virtio-serial 技术实现通信，kernel 版本 v4.8 以上支持vsock 技术，virtio-serial 技术需要proxy 以多路分流的方式对多个容器进程通信，而利用 Vsock 技术通信时则不需要多路分流。 Shim 组件shim 在主机环境中运行，替实际运行在 虚机里的容器处理std I / O 及信号。shim 可以将 上层Containerd-shim 发来的数据流（如stdin）经 由proxy 转交给agent 执行，也可以将agent 经由 proxy 发过来的数据流（stdout/stderr）及信号传给 上层Containerd-shim。它主要负责在虚机外部监 控以及终止容器。 kata在主机上有kata runtime对新的容器进行启动与配置，对于每个在kata VM里面的容器，在主机上有一个对应的kata shim，shim接收客户端API的请求（如docker和kubectl）并通过vsock将请求传递到kata VM里的agent。2 Kata Containers使用QEMU NVDIMM功能提供内存映射的虚拟设备，可用于将虚拟机的根文件系统DAX映射到guest内存地址空间3： ","date":"2022-01-20","objectID":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["容器","docker"],"title":"各个runtime的区别","uri":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["虚拟化"],"content":"kata_container的安装 kata安装 docker配置 ","date":"2022-01-20","objectID":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["容器","docker"],"title":"各个runtime的区别","uri":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["虚拟化"],"content":"遇到的问题 cwy@cwy:~$ sudo docker run busybox uname -a docker: Error response from daemon: OCI runtime create failed: failed to launch qemu: exit status 1, error messages from qemu log: Could not access KVM kernel module: No such file or directory qemu-vanilla-system-x86_64: failed to initialize kvm: No such file or directory: unknown. ERRO[0001] error waiting for container: context canceled 原因是我把它安装在虚拟机上了，需要安装在物理机上才能真正的运行： 原因 原因 此时对于我的vmware虚拟机，我可以将其设置中的： 然后就可以运行了 ","date":"2022-01-20","objectID":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/:1:1","tags":["容器","docker"],"title":"各个runtime的区别","uri":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["虚拟化"],"content":"内核的区别 对于一般的docker容器，其对应的内核信息如下： cwy@cwy:~$ sudo docker run -it ubuntu /bin/bash root@e583629a8af1:/# uname -a Linux e583629a8af1 5.4.0-52-generic #57~18.04.1-Ubuntu SMP Thu Oct 15 14:04:49 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 而主机的内核： cwy@cwy:~$ uname -a Linux cwy 5.4.0-52-generic #57~18.04.1-Ubuntu SMP Thu Oct 15 14:04:49 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 可见docker的主机内核与主机的内核是一样的。 而安装了kata的容器的内核与主机是不一样的： cwy@cwy:~$ sudo vim /etc/docker/daemon.json cwy@cwy:~$ sudo vim /etc/docker/daemon.json cwy@cwy:~$ sudo systemctl daemon-reload cwy@cwy:~$ sudo systemctl restart docker cwy@cwy:~$ sudo docker run -it ubuntu /bin/bash root@a356febe014d:/# uname -a Linux a356febe014d 5.4.60-51.container #1 SMP Thu Oct 22 16:13:49 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux root@a356febe014d:/# Docker使用主机操作系统内核,容器内没有自定义或者使用额外的内核。机器上运行的所有容器都共享此“主机”内核 ","date":"2022-01-20","objectID":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["容器","docker"],"title":"各个runtime的区别","uri":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["虚拟化"],"content":"sysfs与procfs root@9f15bc1ad622:/# cat /proc/mounts|grep sysfs sysfs /sys sysfs ro,nosuid,nodev,noexec,relatime 0 0 root@9f15bc1ad622:/# cat /proc/mounts|grep proc proc /proc proc rw,nosuid,nodev,noexec,relatime 0 0 proc /proc/bus proc ro,relatime 0 0 proc /proc/fs proc ro,relatime 0 0 proc /proc/irq proc ro,relatime 0 0 proc /proc/sys proc ro,relatime 0 0 tmpfs /proc/acpi tmpfs ro,relatime 0 0 firecracker Firecracker is an open source virtualization technology that is purpose-built for creating and managing secure, multi-tenant container and function-based services that provide serverless operational models. 架构如下： 从上图可知firecracker使用的是自己的内核，rootfs与sysfs也需要自己进行创建，所以rootfs不是使用主机的4 在docker里面sysfs，rootfs都使用的是主机的 ","date":"2022-01-20","objectID":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/:3:0","tags":["容器","docker"],"title":"各个runtime的区别","uri":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["虚拟化"],"content":"firecracker安装 安装教程 安装教程 nabla container ","date":"2022-01-20","objectID":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/:4:0","tags":["容器","docker"],"title":"各个runtime的区别","uri":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["虚拟化"],"content":"unikernels unikernels是单地址空间的可以直接在hypervisor上跑的镜像，它将应用和其需要的内核函数打包进了一个镜像： unikernel将内核分开为多个库只把有关的应用需要的库放在单个镜像中，跟VM一样，unikernel也在VMM上运行，由于体量小，unikernel能快速启动和扩展。 ","date":"2022-01-20","objectID":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/:5:0","tags":["容器","docker"],"title":"各个runtime的区别","uri":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["虚拟化"],"content":"nabla ","date":"2022-01-20","objectID":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/:6:0","tags":["容器","docker"],"title":"各个runtime的区别","uri":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["虚拟化"],"content":"nabla的架构 nabla的架构如下： IBM的nabla的基本思想是将“把unikernel当成进程跑”，即把unikernel程序在一个特别的VMM上当做进程运行，nabla containers认为在unikernel和一般的VMM之间的超级调用（hypercall）仍然有较大的攻击可能性，所以用一个有unikernel特性的只允许更少系统调用的监视器能显著提升安全性。nabla tender拦截unikernel发送给VMM的超级调用并翻译为系统调用，linux seccomp（secure computing mode）屏蔽所有Tender不需要的调用： 一个unikernel与nabla结合可以被当做一个主机上的用户空间的进程： ","date":"2022-01-20","objectID":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/:6:1","tags":["容器","docker"],"title":"各个runtime的区别","uri":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["虚拟化"],"content":"nabla安装 安装的主要方法见nabla安装1 或者nabla安装2 执行过程中遇到了报错： cwy@cwy:~/go/src/github.com/nabla-containers/runnc$ make container-build sudo docker build . -f Dockerfile.build -t runnc-build Sending build context to Docker daemon 7.624MB Step 1/7 : FROM golang:1.11 ---\u003e 43a154fee764 Step 2/7 : RUN go get -u github.com/golang/dep/cmd/dep ---\u003e Using cache ---\u003e c96b623cd623 Step 3/7 : RUN apt update ---\u003e Using cache ---\u003e 0b52b5e2cc0e Step 4/7 : RUN apt install -y genisoimage ---\u003e Using cache ---\u003e 0d216af11007 Step 5/7 : RUN apt install -y libseccomp-dev ---\u003e Using cache ---\u003e ac6b324b417f Step 6/7 : RUN apt install -y sudo ---\u003e Using cache ---\u003e c2cd0875f4e8 Step 7/7 : RUN apt install -y jq ---\u003e Using cache ---\u003e dd819ac61acc Successfully built dd819ac61acc Successfully tagged runnc-build:latest sudo docker run --rm -v /home/cwy/go/src/github.com/nabla-containers/runnc:/go/src/github.com/nabla-containers/runnc -w /go/src/github.com/nabla-containers/runnc runnc-build make dep ensure The following issues were found in Gopkg.toml: ✗ unable to deduce repository and source type for \"golang.org/x/sys\": unable to read metadata: unable to fetch raw metadata: failed HTTP request to URL \"http://golang.org/x/sys?go-get=1\": Get http://golang.org/x/sys?go-get=1: dial tcp 216.239.37.1:80: connect: connection refused ProjectRoot name validation failed make: *** [Makefile:70: godep] Error 1 Makefile:52: recipe for target 'container-build' failed make: *** [container-build] Error 2 网上博客说是墙的原因导致的，但是不管我试哪种方法（包括换代理，科学上网，修改hosts）我都是会报这个错，由于不是很清楚该怎么解决，接下来的安装无法继续，但根据原理与架构我可以知道nabla是mount主机的sysfs和procfs5 gVisor gVisor作为主机上的一个进程运行，这个进程提供被沙盒隔离的应用和主机之间的接口，gVisor的思想是保证提供进程模型的情况下尽可能的通过多层防护减小系统应用的攻击，Sentry 是 gVisor 的核心组件，它就像一个简单的操作系统内核，提供了系统调用，进程管理，内存管理等功能。Sentry实现了Linux系统的大多数调用， 以及很多重要的内核函数如信号传递，内存管理，网络堆栈，线程模型等。 gVisor 对系统调用的劫持方法，目前提供了两种劫持模式：KVM 模式，与 ptrace 模式。ptrace 模式的性能不及 KVM 模式。因为应用的每个 SYSCALL 都需要通过 ptrace 访问 Sentry。6 gVisor 兼容 OCI，因此它的 rootfs 的文件来源就来自容器 OCI 镜像各层聚合以后的 rootfs。为了减少 Guest App 直接对 Host 系统调用的依赖，Sentry 使用了 9pfs。应用程序通过 9p 协议与 Runsc 进程通信（内部运行着 Gofer Server 的功能），通过 Runsc 间接地来对 Host 的 rootfs 进行操作。6 当应用调用了那些未被实现的系统调用时，Sentry 会直接报错返回。由于系统调用尚未完备，导致部分软件还不能无缝地运行在 gVisor 中。而且 gVisor 已支持的系统调用中，有若干还必须依赖 Host 内核。当处理这些系统调用时，Sentry 会陷回 Host 模式。6 安装见 安装教程 sysfs和procfs是什么 ","date":"2022-01-20","objectID":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/:6:2","tags":["容器","docker"],"title":"各个runtime的区别","uri":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["虚拟化"],"content":"sysfs sysfs是一个基于内存的文件系统，它的作用是将内核信息以文件的方式提供给用户程序使用。sysfs可以看成与proc,devfs和devpty同类别的文件系统，该文件系统是虚拟的文件系统，可以更方便对系统设备进行管理。它可以产生一个包含所有系统硬件层次视图，与提供进程和状态信息的proc文件系统十分类似。78 ","date":"2022-01-20","objectID":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/:7:0","tags":["容器","docker"],"title":"各个runtime的区别","uri":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["虚拟化"],"content":"procfs ","date":"2022-01-20","objectID":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/:8:0","tags":["容器","docker"],"title":"各个runtime的区别","uri":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["虚拟化"],"content":"procfs和sysfs的区别 What is the difference between procfs and sysfs? proc is the old one, it is more or less without rules and structure. And at some point it was decided that proc was a little too chaotic and a new way was needed. Then sysfs was created, and the new stuff that was added was put into sysfs like device information. So in some sense they do the same, but sysfs is a little bit more structured. Why are they made as file systems? UNIX philosophy tells us that everything is a “file”, therefore it was created so it behaves as files. As I understand it, proc is just something to store the immediate info regarding the processes running in the system. Those parts has always been there and they will probably never move into sysfs. But there is more old stuff that you can find in proc, that has not been moved.9 总结 gVisor和Nabla是沙盒化的runtime，它们可以将主机与容器化过程进一步隔离。 容器化过程不是共享主机内核，而是在Unikernel或内核代理层上运行，然后，该层将代表容器与主机内核进行交互。 由于增加了隔离度，因此这些runtime的受攻击面有所减少，并且使容器进程不太可能对主机产生不安全的影响。 Kata是虚拟化的runtime。 它们是OCI Runtime规范的实现，由虚拟机接口而不是主机内核支持。 他们使用标准Linux内核映像启动轻量级虚拟机，并在该虚拟机中运行“容器化”的过程。 与本机runtime相反，沙盒化和虚拟化runtime在整个容器化过程的整个生命周期中都会对性能产生影响。 在沙盒容器中，有一个额外的抽象层：进程在沙盒unikernel / proxy上运行，它将指令中继到主机内核。 在虚拟化容器中，存在一层虚拟化：该过程完全在虚拟机中运行，这本质上比本地运行慢。 将VM技术（如注重性能的AWS Firecracker）用作VM容器的支持虚拟机类型可以帮助最大程度地减少这种影响。 工具名称 系统调用是否借用host系统调用 procfs、sysfs是否mount自主机 docker 是 是 kata containers 否（来自客户OS内核） 否（来自虚拟机） firecracker 否（来自自带内核） 否（来自自带的文件系统） nabla container 否（来自unikernel，如果没有再用host） 是 gvisor 否（go语言实现的内核的系统调用） 否（来自自带的文件系统） kata与一般容器的区别 ↩︎ 几个容器工具的介绍 ↩︎ 强隔离容器那些事 ↩︎ Firecracker microVMs ↩︎ nabla的文件系统 ↩︎ 谷歌新作gVisor：VM容器融合技术已经到来 ↩︎ sysfs的结构 ↩︎ 使用 /sys 文件系统访问 Linux 内核 ↩︎ procfs与sysfs的区别 ↩︎ ","date":"2022-01-20","objectID":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/:9:0","tags":["容器","docker"],"title":"各个runtime的区别","uri":"/%E5%90%84%E4%B8%AAruntime%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["go"],"content":"go语言概述 Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。 Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。 ","date":"2022-01-19","objectID":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/:1:0","tags":["go","gopl"],"title":"1.go语言结构","uri":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/"},{"categories":["go"],"content":"go语言的关键字，预定义字，运算符 ","date":"2022-01-19","objectID":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/:2:0","tags":["go","gopl"],"title":"1.go语言结构","uri":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/"},{"categories":["go"],"content":"关键字 go语言的关键字有： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var ","date":"2022-01-19","objectID":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/:2:1","tags":["go","gopl"],"title":"1.go语言结构","uri":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/"},{"categories":["go"],"content":"预定义的字 还有大约30多个预定义的字,这些并不是关键字，可以被重新定义： 内建常量: true false iota nil 内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error 内建函数: make len cap new append copy close delete complex real imag panic recover ","date":"2022-01-19","objectID":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/:2:2","tags":["go","gopl"],"title":"1.go语言结构","uri":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/"},{"categories":["go"],"content":"运算符 关于算术运算、逻辑运算和比较运算的二元运算符有： * / % \u003c\u003c \u003e\u003e \u0026 \u0026^ +(加号,字符串拼接符号) -(减号) | ^ == != \u003c \u003c= \u003e \u003e= \u0026\u0026 || 对于前两行的运算符可以加个=,形成对应的简洁形式方便代码的书写，如+=,-=,\u003e\u003e= 二元运算符有五种优先级。在同一个优先级而无括号的情况下，使用左优先结合规则。 关于比较的运算符有： == equal to != not equal to \u003c less than \u003c= less than or equal to \u003e greater than \u003e= greater than or equal to 上面的二元运算符中，有以下几个bit位操作运算符，前面4个操作运算符并不区分是有符号还是无符号数： \u0026 与 AND | 或 OR ^ 异或 XOR \u0026^ 位清空 (AND NOT) \u003c\u003c 左移(SHIFT LEFT) \u003e\u003e 右移(SHIFT RIGHT) 关于位清零：表达式z = x \u0026^ y结果，如果对应y中bit位为1的话，z的bit位为0，否则对应的bit位等于x相应的bit位的值。 左移运算\u003c\u003c用零填充右边空缺的bit位，无符号数的右移运算也是用0填充左边空缺的bit位，但是有符号数的右移运算会用符号位的值填充左边空缺的bit位。 一元运算符有： +(正数) -(负数) !(逻辑非) ","date":"2022-01-19","objectID":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/:2:3","tags":["go","gopl"],"title":"1.go语言结构","uri":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/"},{"categories":["go"],"content":"go程序的基本格式 Go每句话末尾不需要加上分号，除非要在一行中将多个语句、声明隔开。 在编译时，编译器会主动在一些特定的符号后添加分号（比如行末是：一个标识符、一个整数、浮点数、虚数、字符或字符串文字、关键字break、continue、fallthrough或return中的一个、运算符和分隔符++、–、)、]或}中的一个），所以在哪里加分号合适取决于Go语言代码。 gofmt工具会将你的代码格式化为标准格式，并且go工具中的fmt子命令会自动对特定package下的所有.go源文件应用gofmt工具格式化。如果不指定package，则默认对当前目录下的源文件进行格式化。 一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。go程序一般按照下面的程序结构块顺序进行编写： 包声明 这行声明语句表示该文件是属于哪一个package 引入包语句 紧跟着包声明 是一系列import的package名，表示这个文件中引入的package，import声明必须跟在文件的package声明之后。 当我们import了一个包路径包含有多个单词的package时，比如apple/banana通常我们只需要用最后那个单词表示这个包就可以。所以当我们写banana.XXXX时，这个变量指向的是apple/banana包里的变量。 如果包是自定义的包，则可以通过绝对路径或者相对路径进行导入即可。 函数与表达式。 在import语句之后，则是各种方法、变量、常量、类型的声明语句(分别用关键字func, var, const, type来进行定义)。这些内容的声明顺序并没有什么规定，但是建议遵循一定的规范。 例： //包声明 package main //引入包 import \"fmt\" //函数 func main() { //表达式语句 fmt.Println(\"Hello, 世界\") } ","date":"2022-01-19","objectID":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/:3:0","tags":["go","gopl"],"title":"1.go语言结构","uri":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/"},{"categories":["go"],"content":"package包 Go语言的代码是通过package来组织的，和其他语言的库或模块的概念类似，目的是为了支持模块化，封装，单独编译和代码的重用，一个package会包含一个或多个.go结束的源代码文件。每一个源文件都是以一个package xxx的声明语句开头的，这行声明语句表示该文件是属于哪一个package。 package main是一个比较特殊的package。这个package里会定义一个独立的程序，这个程序是可以运行的，而不是像其它package一样对应一个library。 在main这个package里，main函数也是一个特殊的函数，是整个程序的入口。 每个包都有一个独立的名字空间，如image.Decode与utf16.Decode是不同的。 当不同的包之间有依赖关系，则包的初始化会按照包级变量声明出现顺序依次初始化，如果包中有多个.go文件，它们将按照发给编译器的顺序进行初始化，go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。比如，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化了 （包内的.go文件貌似是没有初始化顺序的）。 对于在包级别的变量，如果有初始化表达式则用表达式进行初始化，还有些没有初始化表达式的，例如一些表格数据初始化不是一个简单的赋值语句，可以用一个特殊的init初始化函数来简化初始化工作，每个文件都可以有多个init初始化函数。 ","date":"2022-01-19","objectID":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/:4:0","tags":["go","gopl"],"title":"1.go语言结构","uri":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/"},{"categories":["go"],"content":"作用域 一个声明语句将程序中的试题和一个名字关联，比如一个函数或者一个变量，声明语句的作用域是指源代码中可以有效使用这个名字的范围。 作用域和生命周期的区别： 作用域对应的是一个源代码的文本区域，是一个编译时的属性，而一个变量的声明周期指的是程序运行时变量存在的有效时间段，在此事件区域内可以被程序的其他部分引用，是一个运行时概念。 go语言的语法块由{}所包含的一系列语句，语法块内部的名字无法被外部语法块访问，语法决定了内部声明的名字的作用域范围。 最大的语法块为整个源代码，为全局语法块 对于内置的类型，函数与常量（如int,len,true）在全局作用域，因此可以在整个程序中直接使用。 接着是每个包的包语法块 在函数外部声明的名字处于包级作用域，可以在同一个包中的任何源文件访问 然后是源文件级的作用域 对于导入的包，例如导入的fmt包，则是对应源文件级的作用域，只能在当前文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。 然后就是for,if,switch语句的语法块 ，每个switch或select的分支也有独立的语法块 函数内部的变量则是局部作用域，仅仅函数内部才能访问。控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。 在函数中词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明。还有许多语法块是if或for等，控制流语句构造的。 下面的代码有三个不同的变量x，因为它们是定义在不同的词法域： func main() { x := \"hello!\"//第一个x for i := 0; i \u003c len(x); i++ { x := x[i]//第二个x,变量声明符号右边的x为第一个x if x != '!' { x := x + 'A' - 'a'//第三个x,变量声明符号右边的x为第二个x fmt.Printf(\"%c\", x) // \"HELLO\" (one letter per iteration) } } } 隐含的规则： for语句创建了两个词法域： 一个隐式的部分是循环的初始化部分，条件测试部分和循环后的迭代部分，当然也包含循环体词法域。而花括弧包含的是显式的部分是for的循环体部分词法域 if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域 if条件部分是一个词法域，括号内是另一个词法域 switch条件部分为一个隐式词法域，然后每个是每个分支的词法域 一个典型的例子： var cwd string func init() { cwd, err := os.Getwd() // compile error: unused: cwd if err != nil { log.Fatalf(\"os.Getwd failed: %v\", err) } } 此时变量声明语句会屏蔽外部的cwd，使得外部的cwd没有被初始化，有许多方式可以避免出现类似潜在的问题,最直接的方法是通过单独声明err变量，来避免使用:=的简短声明方式 ","date":"2022-01-19","objectID":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/:5:0","tags":["go","gopl"],"title":"1.go语言结构","uri":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/"},{"categories":["go"],"content":"go语言编码 go语言字符串，以及源文件使用的是utf-8编码，下面开始一步步介绍utf-8编码。 ","date":"2022-01-19","objectID":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/:6:0","tags":["go","gopl"],"title":"1.go语言结构","uri":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/"},{"categories":["go"],"content":"ASCII码 ASCII大家应该比较熟，包含英文字母的大小写、数字、各种标点符号和设置控制符，但是只支持英语字母为语言的国家，不支持其他的字符。 ","date":"2022-01-19","objectID":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/:6:1","tags":["go","gopl"],"title":"1.go语言结构","uri":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/"},{"categories":["go"],"content":"Unicode unicode收集了这个世界上所有的文书符号体系，每个符号都分配一个唯一的叫Unicode码点的无符号数字，Unicode码点对应Go语言中的rune整数类型。 我们可以将一个符文序列表示为一个int32序列。这种编码方式叫UTF-32或UCS-4，每个Unicode码点都使用同样的大小32bit来表示。但是对于有些对应的字符编号较小的字符不需要这么多位数，所以十分浪费存储，于是有了UTF8变长编码 ","date":"2022-01-19","objectID":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/:6:2","tags":["go","gopl"],"title":"1.go语言结构","uri":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/"},{"categories":["go"],"content":"UTF8 UTF8是一个将Unicode码点编码为字节序列的变长编码。UTF8编码由Go语言之父Ken Thompson和Rob Pike共同发明的，现在已经是Unicode的标准。 UTF8编码使用1到4个字节来表示每个Unicode码： 格式 范围 备注 0xxxxxxx 0-127 与ASCII相同，兼容ASCII 110xxxxx 10xxxxxx 128-2047 表示的值\u003c128的不予采用 1110xxxx 10xxxxxx 10xxxxxx 2048-65535 表示的值\u003c2048的不予采用 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536-0x10ffff 其他的值不予采用 如果第一个字节的高位为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节，后续的每个高端bit都以10开头，以此类推。 UTF8的优点： 完全兼容ASCII码 是前缀编码，所以当从左向右解码时不会有任何歧义也并不需要向前查看（像GBK之类的编码，如果不知道起点位置则可能会出现歧义） 没有任何字符的编码是其它字符编码的子串，或是其它编码序列的字串(因此搜索一个字符时只要搜索它的字节编码序列即可，不用担心前后的上下文会对搜索结果产生干扰) UTF8编码的顺序和Unicode码点的顺序一致，因此可以直接排序UTF8编码序列 因为没有嵌入的NUL(0)字节，可以很好地兼容那些使用NUL作为字符串结尾的编程语言 Go语言的源文件采用UTF8编码， 详见unicode包 每一个UTF8字符解码，不管是显式地调用utf8.DecodeRuneInString解码或是在range循环中隐式地解码，如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符\\uFFFD，在印刷中这个符号通常是一个黑色六角或钻石形状，里面包含一个白色的问号�。 UTF8字符串作为交互格式非常方便，但是在程序内部采用rune序列可能更方便，因为rune大小一致，支持数组索引和方便切割。因此string接受到[]rune的类型转换，可以将一个UTF8编码的字符串解码为Unicode字符序列，详见 [2. go语言基础语法.md](2. go语言基础语法.md#####字符串字面量（String Literals）) ","date":"2022-01-19","objectID":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/:6:3","tags":["go","gopl"],"title":"1.go语言结构","uri":"/1.go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/"},{"categories":["go"],"content":"变量 ","date":"2022-01-19","objectID":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:0","tags":["go","gopl"],"title":"2.go语言基础语法","uri":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["go"],"content":"变量的声明 变量的声明形式有: identifier := value 简短变量初始化，一般用于声明并初始化局部变量，变量类型根据表达式自动推导，也可以初始化一组变量：i,j:=0,0,但是要注意代码的可读性，:=变量声明语句，所以左边必须有至少一个新的变量（不必全是），否则无法通过编译 var identifier type = value 显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了 这个形式还可以进行部分的省略： 省略=value :var indentifier type 依赖于字符串的默认初始化零值机制:如果变量没有显式初始化，则被隐式地赋予其类型的零值（zero value），数值类型是0，字符串类型是空字符串\"\"，布尔型为false,接口或引用类型为nil,数组或者结构体等俱黑类型对应的零值为每个元素或者字段均为对应类型的零值。也可一次性初始化多个该类型的变量，如：var i,j,k int， 省略type:var identifier = value 用得很少，除非同时声明多个变量,用这个语句声明多个变量的形式：var a,b,c,d=true,2,3,\"four\" 函数的返回值进行初始化 如：var f,err=os.Open(name) 实践中一般使用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。 注意： 在习惯上，go语言推荐使用驼峰命名法。 new函数 另外一个创建变量的方法是调用内建函数new函数，表达式new(T)将创建一个T类型的匿名变量，初始化为对应类型的零值，然后返回变量地址，返回指针类型为*T。 new创建变量和普通变量声明语句方式创建变量没什么区别，除了不需要声明一个临时变量的名字外。 new函数只是一个预定义的函数，不是一个关键字，因此可以将new这个名字重新定义为别的类型。 ","date":"2022-01-19","objectID":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:1:0","tags":["go","gopl"],"title":"2.go语言基础语法","uri":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["go"],"content":"go数据类型 Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型 基础类型，包括:数字、字符串和布尔型 复合数据类型包括：数组和结构体 引用类型包括：指针、切片、字典、函数、通道 go语言不支持隐式类型转换，如int a = b(其中b为float型),即使两个自定义的类型底层类型是一样的两个也不能直接进行互相赋值，需要进行一个显式的类型转换才能进行相互转换： 对于每一个类型T都有一个对应的类型转换操作T(x),用于将x转换为T类型（当T为指针类型，需要加上括号，如(*int)(x)）,类型转换可以是不同类型的，如将浮点型转换为整型,但是从高精度转换为低精度可能会出现精度丢失以及溢出等问题 类型的可赋值性与可比性 可赋值性根据不同类型有不同的规则，在自定义的新类型需要解释相应的赋值规则，对已有类型的规则很简单：类型必须精确匹配，而nil值可以被赋值给任何接口变量与引用类型，而常量有更加灵活的可赋值性规则来规避显式转换。==与!=的结果与可赋值性相关：第一个操作数相对第二个操作数类型必须数可赋值的或者反过来赋值的。与可赋值性同理，我们也可以对新的自定义的可比较类型的相关规则进行定义。 ","date":"2022-01-19","objectID":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:0","tags":["go","gopl"],"title":"2.go语言基础语法","uri":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["go"],"content":"基础类型 整数（Integer） 整型按照长度分，有以下两个大类： int8,int16,int32,int64 有符号整数采用补码（2’s-complement）形式表示，对于n位的有符号整数，取值范围是$[−2^{n−1},2^{n−1}−1]$ uint8（byte）,uint16,uint32(rune),uint64 无符号数所有的位用于存储值，范围为$[0,2^n-1]$ byte是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数 int16类似c中的short Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用 int64类似c中的long型 int，uint 大小是32或64bit，取决于不同的编译器以及不同的硬件平台 uintptr 无符号的整数类型，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程时才需要 上述的所有类型即使是等价类型，如果需要互相赋值，则必须显示的转换。 tips: 如果没有特殊的要求，最好使用有符号数，否则如果遇到某些索引判断时会出现判断出错问题，如： var i uint for i = 10; i \u003e= 0; i-- { fmt.Println(\"test\") } 因为无符号数的负溢出，会变成正数，此时循环永远不会终止，会导致错误，类似的问题还有很多，所以无符号数往往只有在位运算或其它特殊的运算场景才会使用（就像bit集合、分析二进制文件格式或者是哈希和加密操作等） 浮点数（Floating-Point Numbers） Go语言提供了两种精度的浮点数，float32和float64。它们的算术规范由IEEE754国际标准定义，被所有现代的CPU支持。 浮点数的范围极限值可以在math包找到。详见 a.常用的go标准库.md 。 复数(Complex Numbers) Go语言提供了两种精度的复数类型：complex64和complex128，分别由float32和float64组成实部和虚部。 内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部： var x complex128 = complex(1, 2) // 1+2i var y complex128 = complex(3, 4) // 3+4i fmt.Println(x*y) // \"(-5+10i)\" fmt.Println(real(x*y)) // \"-5\" fmt.Println(imag(x*y)) // \"10\" 布尔型（Booleans） 布尔类型值只有两种:true,false。一元操作符!对应逻辑非操作。 布尔值可以和\u0026\u0026（AND）和||（OR）操作符结合，和C语言类似：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不在被求值。 因为\u0026\u0026的优先级比||高（助记：\u0026\u0026对应逻辑乘法，||对应逻辑加法，乘法比加法优先级要高）如下的代码不需要加括号： if 'a' \u003c= c \u0026\u0026 c \u003c= 'z' || 'A' \u003c= c \u0026\u0026 c \u003c= 'Z'{ // ... } 字符串(Strings) 一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据（包括byte值0），文本字符串通常被解释为采用UTF8的编码Unicode码点（rune）序列。 内置的len函数可以返回一个字符串中的字节数目，而不是rune字符数目,对于rune字符数，可以使用unicode/utf8来进行统计： import \"unicode/utf8\" s := \"Hello, 世界\" fmt.Println(len(s)) // \"13\":\"Hello, \"共7个；\"世界\"共6个；\\0为1个 fmt.Println(utf8.RuneCountInString(s)) // \"9\":\"Hello, \"共7个；\"世界\"共2个 索引操作s[i]返回第i个字节的字节值，子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串不管是i还是j都可以被忽略，如果i被省略的话将使用0代替，如果j被省略的话将使用len(s)代替。 关于字符串的不可改性：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值,但是并不会导致原始的字符串值被改变： s := \"left foot\" t := s s += \", right foot\" fmt.Println(s) // \"left foot, right foot\" fmt.Println(t) // \"left foot\" 因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的： s[0] = 'L' // compile error: cannot assign to s[0] 不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。下图是字符串共享时在内存中的布局，它们共用了底层存储的数据： 字符串字面量（String Literals） 字符串的值可以用字符串字面量(String Literals， 有的翻译也叫面值),形式上就是带双引号的字节序列： \"hello 世界！\" \"こんにちは世界！\" 因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串字面量中：在一个双引号包含的字符串字面量中，可以用以反斜杠\\开头的转义序列插入任意的数据： 转义字符 含义 \\a 响铃（或警告） \\b 退格符 \\f 换页符 \\n 换行符（跳到下一行的同一个位置） \\r 回车符（返回行首） \\t 制表符 \\v 垂直制表符 \\' 单引号 \\\" 双引号 \\\\ 反斜杠 \\xhh 十六进制数对应的单字节字符，两个h表示十六进制数字，大写或小写都可以（必须是两位，因为表示的是一个字节，范围为0~255） \\ooo 八进制数对应的单字节字符，三个o表示八进制数字，大写或小写都可以（必须是三位，不能超过\\377，\\377对应十进制为255） \\uhhhh unicode字符对应的数值，对应16bit的码点值 \\Uhhhhhhhh unicode字符对应的数值，对应32bit的码点值 一个原生的字符串字面量使用反引号而不是双引号，在原生的字符串面值中，没有转义操作，全部的内容都是字面的意思，因此一个程序中的原生字符串面值可能跨越多行： const GoUsage = `Go is a tool for managing Go source code. Usage: go command [arguments] ...` 唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统(Windows系统会把回车和换行一起放入文本文件中) 原生字符串面值用于编写正则表达式会很方便,同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。 有很多Unicode字符很难直接从键盘输入，则可以用上面的\\u和\\U进行转义输入，以下的字符串表示的内容完全一致： \"世界\" \"\\xe4\\xb8\\x96\\xe7\\x95\\x8c\" \"\\u4e16\\u754c\" \"\\U00004e16\\U0000754c\" 拿世举例：\\xe4\\xb8\\x96对应的二进制为：11100100 10111000 10010110，是一个标准的unicode二进制码，\\u4e16则是unicode的对应的值的对应的二进制：01001110 00010110。 字符串与rune切片 string接受到[]rune的类型转换，可以将一个UTF8编码的字符串解码为Unicode字符序列： s := \"プログラム\" fmt.Printf(\"% x\\n\", s) // e3 83 97 e3 83 ...是标准的UTF-8编码 r := []rune(s) fmt.Printf(\"%x\\n\", r) //[30d7 30ed 30b0 30e9 30e0]对应每一个字符的unicode编码值 如果是将一个[]rune类型的Unicode字符slice或数组转为string，则对它们进行UTF8编码： fmt.Println(string(r)) // \"プログラム\" 将一个整数转型为字符串意思是生成以只包含对应Unicode码点字符的UTF8字符串： fmt.Println(string(65)) // \"A\", not \"65\" fmt.Println(string(0x4eac)) // \"京\" 如果对应码点的字符是无效的，则用'\\uFFFD’无效字符作为替换: fmt.Println(string(1234567))//\"�\" 字符串和Byte切片 标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。 bytes包也提供了很多类似功能的函数，用于操作字节切片([]byte类型，与字符串有相同的结构)。 因为字符串是只读的，因此按照增量的方式构建字符串会导致很多分","date":"2022-01-19","objectID":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:1","tags":["go","gopl"],"title":"2.go语言基础语法","uri":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["go"],"content":"复合数据类型(Composite Types) 以不同的方式组合基本类型可以构造出来的复合数据类型，包括数组、slice(切片)、map和结构体。 数组(Arrays) 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。 数组的长度是数组类型的一个组成部分，因此补充长度的元素同类的数组是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。 数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的len函数将返回数组中元素的个数。 数组的声明与初始化 数组的一般声明形式如下： var identifier [num]type = [num]type{value_0,value_1,value_2,...value_num} 其中num表示数组的长度，type为数组元素的基本类型。 可以省略等式右边，此时，数组的每个元素都被初始化为元素类型对应的零值，例如： var a [3]int //a数组的各个元素都是int类型的零值，即0 也可以省略数组的长度，使用...来替代长度，则表示数组的长度是根据初始化值的个数来计算: identifier := [...]type{value_0,value_1,value_2,...value_num} 如： q := [...]int{1, 2, 3} fmt.Printf(\"%T\\n\", q) // \"[3]int\" 也可以指定一个索引和对应值列表的方式初始化: identifier := [...]type{index_0:value_0,index_1:value_1,...index_n:value_n} 如： type Currency int const ( USD Currency = iota // 美元 EUR // 欧元 GBP // 英镑 RMB // 人民币 ) symbol := [...]string{USD: \"$\", EUR: \"€\", GBP: \"￡\", RMB: \"￥\"} fmt.Println(RMB, symbol[RMB]) // \"3 ￥\" 在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而且没用到的索引可以省略，省略的是零值。 数组的比较 只有当两个数组的所有元素都是相等的时候数组才是相等的 其他注意： 与大多数语言不同，如果Go中的数组作为函数的参数，那么实际传递的参数是一份数组的拷贝，而不是数组的指针 函数参数传递的机制导致传递大的数组类型将是低效的,且数组的作用结果不是直接在原数组上 结构体(Structs) Go 语言中没有类的概念，因此在 Go 中结构体有着更为重要的地位。最常用的方法是使用关键字 type 和 struct 来定义一个结构体: type identifier struct{ attribute1 type1 attribute2 type2 ... } 遇到结构简单的结构体的也可以进行一些简化： type identifier struct{ a,b,c type1 } 结构体字面量： 结构体值也可以用结构体面值表示。 第一种方法，结构体面值可以指定每个成员的值： type Point struct{ X, Y int } p := Point{1, 2} 上述的方法要求以结构体成员定义的顺序为每个结构体成员指定一个面值，一般只在定义结构体的包内部使用，或者是在较小的结构体中使用 第二种写法，以成员名字和相应的值来初始化，可以包含部分或全部的成员： anim := gif.GIF{LoopCount: nframes} 在这种形式的结构体面值写法中，如果成员被忽略的话将默认用零值，顺序不做要求 结构体的比较： 如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的 可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型 结构体嵌入和匿名结构体(Struct Embedding and Anonymous Fields): 结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，这样就可以通过简单的点运算符x.f来访问匿名成员链中嵌套的x.d.e.f成员。 Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字，这类成员就叫匿名结构体（或叫匿名成员）。匿名结构体的数据类型必须是命名的类型或指向一个命名的类型的指针。 type Circle struct { Point Radius int } type Wheel struct { Circle //匿名成员 Spokes int } 对于匿名成员，可以由于嵌入的特性直接访问嵌入的结构体的成员： var w Wheel w.X = 8 // 等价于w.Circle.Point.X = 8 w.Y = 8 // 等价于w.Circle.Point.Y = 8 w.Radius = 5 // 等价于w.Circle.Radius = 5 w.Spokes = 20 匿名结构体的缺点是无法通过简短的方式对结构体赋值: w = Wheel{8, 8, 5, 20} // compile error: unknown fields w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields 只能老老实实地赋值： w = Wheel{Circle{Point{8, 8}, 5}, 20} w = Wheel{ Circle: Circle{ Point: Point{X: 8, Y: 8}, Radius: 5, }, Spokes: 20, // NOTE: trailing comma necessary here (and at Radius) } fmt.Printf(\"%#v\\n\", w) // Output: // Wheel{Circle:Circle{Point:Point{X:8, Y:8}, Radius:5}, Spokes:20} w.X = 42 fmt.Printf(\"%#v\\n\", w) // Output: // Wheel{Circle:Circle{Point:Point{X:42, Y:8}, Radius:5}, Spokes:20} 因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员。同时，因为成员的名字是由其类型隐式地决定的，所有匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。 即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以在包内用简短形式访问匿名成员嵌套的成员： w.X = 8 但是在包外部，因为circle和point没有导出不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的,下面的代买可以在包内运行成功，但是在包外的时候，这代码将会报如下的错误： //包外使用如下语句 a := test.Wheel{} a.circle.point.X = 8 //报错：a.circle undefined (cannot refer to unexported field or method circle) 匿名成员并不要求是结构体类型，其实任何命令的类型都可以作为结构体的匿名成员，这样做的意义是：是匿名类型的方法集，简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。 外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一个有简单行为的对象组合成有复杂行为的对象。 注意： 结构体成员的输入顺序也有重要的意义，顺序不一样的结构体不是同一个结构体。 如果结构体成员名字是以大写字母开头的，那么该成员就是导出的，由go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。 一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。 结构体变量的成员可以通过点操作符访问：identifier.attribute1,并且可以直接对其赋值，取地址，然后通过指针访问。结构体本身也可以被取址。 结构体类型的零值是每个成员都对是零值。通常会将零值作为最合理的默认值。 如果结构体没有任何成员的话就是空结构体，写作struct{}。它的大小为0，也不包含任何信息。有些Go语言程序员用map带模拟set数据结构时，用它来代替map中布尔类型的value，只是强调key的重要性，但是因为节约的空间有限，语法比较复杂，通常避免这样的用法。 如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回。 ","date":"2022-01-19","objectID":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:2","tags":["go","gopl"],"title":"2.go语言基础语法","uri":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["go"],"content":"引用类型 切片(slice) Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。类似于Python的list，一个slice类型一般写作[]T，其中T代表slice中元素的类型，slice的语法和数组很像，只是没有固定长度而已。 一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能(slice的底层确实引用一个数组对象)。一个slice由三个部分构成：指针、长度和容量： 指针指向第一个slice元素对应的底层数组元素的地址(slice的第一个元素并不一定就是数组的第一个元素)。 长度对应slice中元素的数目。内置的len函数返回slice的长度。 容量是从slice的开始位置到底层数据的结尾位置。长度不能超过容量。内置的cap函数返回slice的容量。 切片的定义与初始化：var identifier []type var s []int初始化为长度为0的空切片,默认为nil s :=[] int {1,2,3}直接初始化 s := arr[startIndex:endIndex]数组arr的引用 slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。新的slice将只有j-i个元素。类似大多数支持切片的语言，如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用len(s)代替。 slice和数组的字面值语法很类似，不过不需要定义长度，或使用内置的make函数来创建切片: var s []type = make([]type, len) //或者s := make([]type, len) make([]T, length, capacity)此处的length是切片的初始长度，capacity指的是切片的容量，切片长度不能超过该长度（容量部分可以省略，在这种情况下，容量将等于长度） 多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠： months := [...]string{1: \"January\", /* ... */, 12: \"December\"} //定义months数组 Q2 := months[4:7] //由数组生成切片 summer := months[6:9]//由数组生成切片 如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大： fmt.Println(summer[:20]) // panic: out of range endlessSummer := summer[:5] // extend a slice (within capacity) fmt.Println(endlessSummer) // \"[June July August September October]\" append函数 一般的格式为append(slice,element1,element2,element3...),设置可以增加slice，append(slice,slice1,slice2,slice3...) 返回增加元素后的slice，所以一般的用法是slice =append(slice,element) 底层原理：每次调用append函数，必须先检测slice底层数组是否有足够的容量来保存新添加的元素。 如果有足够空间的话，直接扩展slice（依然在原有的底层数组之上），将新添加的y元素复制到新扩展的空间，并返回slice 如果没有足够的增长空间的话，append函数则会先分配一个足够大的slice用于保存新的结果，先将输入的x复制到新的空间，然后添加y元素 根据底层原理，append函数返回的slice是可能与原来的slice不共用底层的数组， 会改变长度甚至容量与指针。 切片的比较 slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。(标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型slice，我们必须自己展开每个元素进行比较) 可以自己写函数进行切片的相等的判断： func equal(x, y []string) bool { if len(x) != len(y) { return false } for i := range x { if x[i] != y[i] { return false } } return true } slice不直接支持比较运算符的原因： 一个slice的元素是间接引用的，一个slice甚至可以包含自身。 一个固定值的slice在不同的时间可能包含不同的元素，因为底层数组的元素可能会被修改。 slice唯一合法的比较操作是和nil比较： if summer == nil { /* ... */ } 一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0(slice的nil值类似于NULL，是没有底层的内存空间的)。与任意类型的nil值一样，我们可以用 []int(nil)类型转换表达式来生成一个对应类型slice的nil值 但是也有非nil值的slice的长度和容量也是0的，例如[]int{}或make([]int, 3)[3:]。 var s []int // len(s) == 0, s == nil s = nil // len(s) == 0, s == nil s = []int(nil) // len(s) == 0, s == nil s = []int{} // len(s) == 0, s != nil 因此，如果需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断，除此之外，一个nil值的slice的行为和其它任意0产长度的slice一样。 字典(map) map类型可以写为map[K]V，其中K和V分别对应key和value。 map中所有的key都有相同的类型，所有的value也有着相同的类型。 其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。对于V对应的value数据类型则没有任何的限制。 虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法，最坏的情况是可能出现的NaN和任何浮点数都不相等 Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。 map存储了键/值（key/value）的集合，对集合元素，提供常数时间的存、取或测试操作。键可以是任意类型，只要其值能用==运算符比较（最常见的例子是字符串），值则可以是任意类型。 map的定义： var map_identifier map[key_type]value_type 不初始化的 map 是 nil，如果不初始化map，那么就会创建一个nil map。nil map不能用来存放键值对。因此，map上的大部分操作，包括查找、删除、len和range循环都可以安全工作在nil值map上，它们的行为和一个空的map类似。但是向一个nil值的map存入元素将导致一个panic异常 创建map并初始化：var map_indentifier := map[key_type]value_type{} 经过初始化后的此map不等于nil map_identifier := make(map[key_type]value_type) 也可以通过字面量进行初始化 ages := map[string]int{ \"alice\": 31, \"charlie\": 34, } 这相当于： ages := make(map[string]int) ages[\"alice\"] = 31 ages[\"charlie\"] = 34 map的读取： map的读取可以通过键来读取：map_indentifier[key_name],map中不含某个键时，首次读到时，值将被计算为其类型的零值。 但是有的时候为了区分这个值是真正的零值还是因为不存在而返回的零值（比如map[string]int代表名字与成绩对应的map，不能确定是否是因为没有这个人导致成绩为0还是本身得0分），可以使用如下的方法进行判断该键的值是否存在： if age, ok := ages[\"bob\"]; !ok { /* ... */ } map的下标语法将产生两个值，第二个是一个布尔值，用于报告元素是否真的存在 map的遍历： 要想遍历map中全部的键值对的话，可以使用range风格的for循环实现： for name, age := range ages { fmt.Printf(\"%s\\t%d\\n\", name, age) } Map的迭代顺序是不确定的 map的删除： 删除可以使用map的delete函数：delete(map_indentifier,key_name) map的比较： 和slice一样，map之间也不能进行相等比较，唯一的例外是和nil进行比较 注意与技巧： map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作 禁止对map元素取址的原因是map可能随着元素数量的增长而","date":"2022-01-19","objectID":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:3","tags":["go","gopl"],"title":"2.go语言基础语法","uri":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["go"],"content":"go语句 ","date":"2022-01-19","objectID":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:0","tags":["go","gopl"],"title":"2.go语言基础语法","uri":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["go"],"content":"类型声明语句 与C语言中typedef关键字功能类似，go中有type关键字进行创建新的类型名字，使其和现有的类型具有相同的底层结构，新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同页式不兼容的 一般用法： type new_type_name type_name 类型声明语句一般出现在包一级，如果首字母大写，则在外部包也可以使用。 ","date":"2022-01-19","objectID":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:1","tags":["go","gopl"],"title":"2.go语言基础语法","uri":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["go"],"content":"赋值语句 一般赋值语句 最简单的复制语句：identifier=value 加减乘除二元运算符赋值语句 二元赋值运算符有：+=,-=,*=,/=,可以省去对符号的重复计算 自增与自减 值得注意的是，与C/C++不同，自增++与自减--都是语句而非表达式，所以go不能出现x=i++这样的语句，同时，++只是右运算符，不能出现在变量的左侧。 元组赋值 元组赋值允许同时更新多个变量的值，赋值前会将赋值语句右边所有表达式先进行求值 ，然后统一更新左边对应变量的的值： x,y=y,x i,j,k=1,2,3 f,err=os.Open(\"foo.txt\") 隐式赋值 很多赋值都是隐式的，比如函数调用的给形参赋值，return语句隐式将值赋给结果变量，复合类型的字面量表达式赋值等。不管是显式还是隐式，只要变量与值的是有可赋值性的即可。 ","date":"2022-01-19","objectID":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:2","tags":["go","gopl"],"title":"2.go语言基础语法","uri":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["go"],"content":"比较语句 比较运算符与大部分主流编程语言相似：\u003e,\u003e=,==,\u003c=,\u003c,得到的结果为true或false,只有数据类型一样的两个变量才能得到这些内置运算符的支持，如果两个值的类型不同则不能直接进行比较。 range range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。 ","date":"2022-01-19","objectID":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:3","tags":["go","gopl"],"title":"2.go语言基础语法","uri":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["go"],"content":"循环语句 go语言的循环语句只有for循环一种，但是有多个变种，方便不同情况下使用： 最一般情况： for initialization; condition; post { // zero or more statements } ` for循环三个部分不需括号包围。大括号强制要求，左大括号必须和post语句在同一行。 initialization initialization语句是可选的，在循环开始前执行。initalization如果存在，必须是一条简单语句，即，短变量声明、自增语句、赋值语句或函数调用。 condition condition是一个布尔表达式，其值在每次循环迭代开始时计算。如果为true则执行循环体语句 post post语句在循环体执行结束后执行，之后再次对condition求值。condition值为false时，循环结束。 类“while”语句 for循环的这三个部分每个都可以省略，如果省略initialization和post，分号也可以省略： // a traditional \"while\" loop for condition { // ... } 死循环 如果连condition也省略了，像下面这样 // a traditional infinite loop for { // ... } 这就变成一个无限循环，尽管如此，还可以用其他方式终止循环，如一条break或return语句。 range与for结合 for循环的另一种形式，在某种数据类型的区间（range）上遍历，如字符串或切片： for index,i:=range slide{ //... } 每次循环迭代，range产生一对值：索引以及在该索引处的元素值。 有时候不需要索引，但range的语法要求，要处理元素，必须处理索引。一种思路是把索引赋值给一个临时变量（如temp）然后忽略它的值，但Go语言不允许使用无用的局部变量（local variables），因为这会导致编译错误。 Go语言中这种情况的解决方法是用空标识符，即_（也就是下划线）。空标识符可用于在任何语法需要变量名但程序逻辑不需要的时候（如：在循环里）丢弃不需要的循环索引，并保留元素值。 ","date":"2022-01-19","objectID":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:4","tags":["go","gopl"],"title":"2.go语言基础语法","uri":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["go"],"content":"条件判断语句 if语句条件两边也不加括号，但是主体部分需要加。if语句的else部分是可选的。 if 布尔表达式 { /* 在布尔表达式为 true 时执行 */ } else{ /* 在布尔表达式为 false 时执行 */ } ","date":"2022-01-19","objectID":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:5","tags":["go","gopl"],"title":"2.go语言基础语法","uri":"/2.go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["go"],"content":"方法(methods) 一个面向对象的程序会用方法来表达其属性和对应的操作，这样使用这个对象的用户就不需要直接操作对象，而是借助方法来做这些事情。 ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:0:0","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"方法的声明 在函数声明时，在其名字之前放上一个变量，即是一个方法： func (identifier Type) name(parameter-list) (result-list) { body } 其中identifier称为方法的接收器（receiver），Go并不会像其它语言那样用this或者self作为接收器，接收器名字可以自定义，例如： type Point struct{ X, Y float64 } type func (p Point) Distance(q Point) float64 { return math.Hypot(q.X-p.X, q.Y-p.Y) } func main(){ p := Point{1, 2} q := Point{4, 6} fmt.Println(p.Distance(q)) } p.Distance表达式称为选择器（selector，又称选择子），因为会给p合适的名为Distance的方法执行（因为Distance方法可能不止一个）,选择器也可以用来选择结构类型中的某些字段值，如p.X。方法与字段在同一个命名空间，因此如果声明一个X方法是非法的。 go语言运行给任何类型定义方法，包括Go自带的各种类型，指针与接口除外。 ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:1:0","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"指针作为参数的方法 有时为了避免实参拷贝为形参，就需要用到指针而不是对象来声明方法： func (p *Point) ScaleBy(factor float64) { p.X *= factor p.Y *= factor } 这个方法的名字是(*Point).ScaleBy，其中括号是必须的，没有括号的这个表达式可能被理解为*(Point.ScaleBy)。只有类型（如Point）与指向它的指针类型（如*Point）是唯一可以出现在receiver声明处的类型。在声明方法的时候，如果一个类型本身是指针的话，不允许其出现在receiver中： type P *int func (P) f() { /* ... */ } // compile error: invalid receiver type 想要调用指针类型方法，只需要提供一个该类型的指针即可： p := Point{1, 2} pptr := \u0026p pptr.ScaleBy(2) fmt.Println(p) // \"{2, 4}\" 上述的操作可以更简单的表达，如果对上述的p直接执行p.ScaleBy(2)，编译器会隐式帮程序员用\u0026p调用ScaleBy方法： p := Point{1, 2} p.ScaleBy(2) fmt.Println(p) // \"{2, 4}\" 这种简单的方法只适用于变量，包括struct里面的成员变量（如p.X）以及数组或切片里面的元素（如某数组第一个元素perim[0]）,但是不能适用于取不了地址的receiver来调用指针方法： Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal 但如果*Point类型的receiver来调用Point类型的方法是合法的，因为可以通过地址找到这个变量，只需加载receiver的指针指向的值即可，同理于上面p可以隐式插入\u0026符号取址，此时编译器也会对指针隐式插入*操作符进行取值，因此下面两个语句是等效的： pptr.Distance(q) (*pptr).Distance(q) 上述的过程进行总结如下： 不管你的method的receiver是指针类型还是非指针类型，都是可以通过对应的指针/非指针类型进行调用的，编译器会帮你隐式做类型转换（只要可以取址或者可以取值）。 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的内部： 第一方面：这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝 第二方面：是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝 ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:2:0","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"nil也是一个合法的receiver值 就像一些函数允许nil值的变量作为参数，方法也可以用nil指针作为receiver，尤其当nil对于对象来说说合法的零值时，如map或slice。但是不能直接使用nil.method()调用方法，因为nil字面量编译器无法判断其类型。 ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:3:0","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"通过嵌入结构体来扩展类型 如果有结构体ColorPoint: type ColoredPoint struct { Point color.RGBA } 该结构体嵌入了Point结构体，因此也“继承”了Point的方法，但是该方法的参数并不会自动变成ColorPoint： var p = ColoredPoint{Point{1, 1}, red} var q = ColoredPoint{Point{5, 4}, blue} p.Distance(q) // compile error: cannot use q (ColoredPoint) as Point p.Distance(q.Point) 除非在ColorPoint内再写一遍Distance方法（如果此时仍然将方法命名为Distance则会发生对Point.Distance方法的覆盖）： func (p ColoredPoint) Distance(q ColoredPoint) float64 { return p.Distance(q.Point) } 嵌入结构体的方法查找顺序为： 首先查找这个类型的方法 接着是内嵌的结构体对应的方法 如果内嵌结构体还有内嵌的结构，则递归查找下去 上述顺序找到就停止下一步的查找。 ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:4:0","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"方法值和表达式（method value and expression） 方法值： 格式：identifier.method 对于常用的p.Distance()方式，其实可以分成两步：首先独立得到selector：distanceFromP := p.Distance，selector会返回一个方法值（method value）：一个将方法（Point.Distance）绑定到特定selector得到的函数。 所以方法值本质上是一个函数 p := Point{1, 2} q := Point{4, 6} distanceFromP := p.Distance // method value fmt.Println(distanceFromP(q)) // \"5\" var origin Point // {0, 0} fmt.Println(distanceFromP(origin)) // \"2.23606797749979\", sqrt(5) scaleP := p.ScaleBy // method value scaleP(2) // p becomes (2, 4) scaleP(3) // then (6, 12) scaleP(10) // then (60, 120) 如果包内的API调用一个函数值（如distanceFromP,scaleP），且希望这个函数变量主要用于调用一个特定的receiver（如p，q），方法值非常有效。 方法表达式： 格式：Type.method 与方法变量相关的还有方法表达式（method expression），调用一个方法时，与调用函数相比，需要提供selector，并根据对应的语法（如p.Distance）进行调用。对于类型T，方法表达式有T.f和(*T).f两种，这两种表达式得到的类型均为函数，这个函数将第一个参数作为receiver，余下的参数即对应方法的参数： p := Point{1, 2} q := Point{4, 6} distance := Point.Distance // method expression fmt.Println(distance(p, q)) // \"5\" fmt.Printf(\"%T\\n\", distance) // \"func(Point, Point) float64\" scale := (*Point).ScaleBy scale(\u0026p, 2) fmt.Println(p) // \"{2 4}\" fmt.Printf(\"%T\\n\", scale) // \"func(*Point, float64)\" 如果需要在多个方法中经常使用某个特定类型T的某个特定的方法f，就可以将这个类型的方法单独用一个变量来表示（e:=T.f），这个变量就可以用方法表达式来得到，而所有的方法都属于同一种类型T，因此这个变量可以在不同情况更换不同的方法表达式得到的函数（从e=T.f到e=T.g）: type Point struct{ X, Y float64 } func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} } func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} } type Path []Point func (path Path) TranslateBy(offset Point, add bool) { var op func(p, q Point) Point if add { op = Point.Add } else { op = Point.Sub } for i := range path { // Call either path[i].Add(offset) or path[i].Sub(offset). path[i] = op(path[i], offset) } } ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:5:0","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"封装（encapsulation） 一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。对于不可见性，go语言只有一个方式：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会，所以如果要封装一个对象，必须将其定义为一个struct： type IntSet struct { words []uint64 } 这种基于名字的手段使得在go语言中的封装单位是包，而不是其他语言的类型，所以go语言的一个struct类型字段对同一个包的所有代码都可见。 封装提供了三方面的有点： 调用方不能直接修改对象的变量值，只需要关注少量语句与变量 隐藏实现细节 最重要地，阻止外部包调用方对对象内部的值进行肆意修改，只允许按照一定的规则修改内容（比如setter，getter等） go不禁止直接导出字段，但是一旦进行了导出，就无法在不改变API兼容性的情况下撤销导出（所以最初的设计需要额外小心）。 接口（interface） 接口类型是对其他类型行为的抽象和概括。go语言接口类型的独特之处在与它是满足隐式实现的，即我们没有必要对于给定的具体类型定义所有满足的接口类型，拥有一些必需的方法就够了。很多Go程序中都尽可能多的去使用标准库中的接口。 ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:6:0","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"接口即约定 接口类型是一种抽象的类型，不会暴露他所代表的对象内部值的结构和这个对象支持的基础操作的集合，它们只会展示出它们自己的方法，所以，使用者使用接口对象时，接口类型封装和隐藏具体类型和它的值，即使该类型有其他的方法，接口类型也只能暴露接口定义的方法而不能使用其他方法。 ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:7:0","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"接口的定义 接口定义的格式为： type T interface{ Func(indentifier_list)(return_value_list) } 接口也可以通过现有接口的组合进行定义,这种方法称为接口的嵌套： type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } type ReadWriter interface { Reader Writer } 当然也可以直接写在在内部： type ReadWriter interface { Read(p []byte) (n int, err error) Write(p []byte) (n int, err error) } 或者混搭： type ReadWriter interface { Read(p []byte) (n int, err error) Writer } 上述的顺序也对接口的定义没有影响。 ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:8:0","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"接口的实现 一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口。 // 对于空接口，什么方法都不需要实现 var any interface{} any = true any = 12.34 any = \"hello\" any = map[string]int{\"one\": 1} any = new(bytes.Buffer) 非空的接口类型通常由一个指针类型来实现的，特别是当接口类型一个或多个方法暗示会修改receiver的情况（如Write函数）。 注意： 虽然对于指针方法，编译器会隐式转换(*Type).method与Type.method，但是这两个方法是不一样的，所以实现某个接口的时候这两个方法会被当做两个不同方法 ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:9:0","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"接口值 概念上讲，接口之由两个部分组成：一个具体类型和该类型的一个值，二者称为接口的动态类型（dynamic type）与动态值（dynamic value）。提供每个类型信息的值被称为类型描述符（type descriptor），比如类型的名称和方法。 在一个接口值中，类型部分代表与之相关类型的类型描述符。 ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:10:0","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"接口的零值 一个接口的零值为nil，此时动态类型与动态值均为nil： 比如对于接口w，只要执行w=nil，即可使w设置为零值。 值得注意的是，一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的，所以，动态类型不为空，而动态值为空的时候，接口也不为空： 此时如果对上面的w进行写操作会导致panic，因为该指针为空，无法写入内容。 ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:10:1","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"接口的使用 随着接口变量的赋值与操作，接口的动态类型与动态值可能会变化： var w io.Writer //接口类型：io.Writer 动态类型：nil 动态值：nil w = os.Stdout //接口类型：io.Writer 动态类型：*os.File 动态值：os.Stdout //上句等价于：w = io.Writer(os.Stdout) w = new(bytes.Buffer) //接口类型：io.Writer 动态类型：*bytes.Buffer 动态值：bytes.Buffer指针值，此时buffer里为空 w = nil //接口类型：nil 动态类型：nil 动态值：nil 一个接口值可以持有任意大的动态值。从概念上讲，不论接口值多大，动态值总是可以容下它。 ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:10:2","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"接口的可比较性 接口类型与众不同，接口有时候是可比较的，有时是不可比较的。如果该动态类型是不可比较的，那么就会出现panic，当接口类型可比较，接口值可以使用==和!=来进行比较,两个接口值相等仅当它们都是nil值或者它们的动态类型与动态值相等。 ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:10:3","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"类型断言 类型断言（Type Assertions）用来从它的操作数中把具体类型的值提取出来，类型断言会检查作为操作数的动态类型是否满足指定的断言类型。类型断言作用于接口值，格式为：x.(T)，其中x是一个接口类型的变量，T是一个类型。 如果T是一个具体的类型，则会判断x的动态类型是否为T类型，如果是则类型断言的结果就是x的动态值，否则会panic： var w io.Writer w = os.Stdout f := w.(*os.File)// success: f == os.Stdout c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer 如果T是接口类型， 则会断言检查x的动态类型是否满足T接口，如果满足，动态值并不会提取出来，而是返回与动态类型与动态值相等的该类型接口的接口值，如果该动态类型不满足接口所需的方法，则会panic： var w io.Reader w = os.Stdout f := w.(io.ReadWriter)//f的接口类型变为了io.ReadWriter,f的动态类型为*os.File f.Write([]byte(\"asd\"))//此时输出“asd” w = new(ByteCounter) rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method 如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。一般的操作是将接口转化为要求更严格的接口，很少要从一个接口类型向一个要求更宽松的类型做类型断言（即更少的方法，且方法集合是子集），因为除了操作nil之外，其他情况与赋值一致。 如果类型断言出现在一个有两个返回值的赋值操作中，则第二个参数表示成功与否的布尔值，这个操作不会在失败的时候发生panic： var w io.Writer = os.Stdout f, ok := w.(*os.File)// success: ok, f == os.Stdout b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil 当类型断言操针对象是一个变量的时候，可以将该变量覆盖使用： if w, ok := w.(*os.File); ok { // ...use w... } ","date":"2022-01-19","objectID":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:11:0","tags":["go","gopl"],"title":"3.go语言的面向对象编程","uri":"/3.go%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["go"],"content":"math包 ","date":"2022-01-19","objectID":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/:1:0","tags":["go","gopl"],"title":"a.常用的go标准库","uri":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["go"],"content":"math.IsNaN 函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。虽然可以math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的（在浮点数中，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示）: nan := math.NaN() fmt.Println(nan == nan, nan \u003c nan, nan \u003e nan) 结果是： false false false ","date":"2022-01-19","objectID":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/:1:1","tags":["go","gopl"],"title":"a.常用的go标准库","uri":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["go"],"content":"math.MaxType与math.minType math.MaxFloat32表示float32能表示的最大数值 math.MinFloat32表示float32能表示的最小数值 math.MaxFloat64表示float64能表示的最大数值 math.MinFloat64表示float64能表示的最小数值 以此类推 ","date":"2022-01-19","objectID":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/:1:2","tags":["go","gopl"],"title":"a.常用的go标准库","uri":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["go"],"content":"math/cmplx 包含了常见的复数处理函数，比如cmplx.Sqrt(-1)可以得到1i ","date":"2022-01-19","objectID":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/:1:3","tags":["go","gopl"],"title":"a.常用的go标准库","uri":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["go"],"content":"unicode包 提供了诸多处理rune字符相关功能的函数（比如区分字母和数组，或者是字母的大写和小写转换等），unicode/utf8包则提供了用于rune字符序列的UTF8编码和解码的功能 ","date":"2022-01-19","objectID":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/:2:0","tags":["go","gopl"],"title":"a.常用的go标准库","uri":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["go"],"content":"unicode/utf8 RuneCount(p []byte) int 返回p中的码点数 RuneCountInString(s string) (n int) 统计字符串s中包含的码点数 DecodeRune(p []byte) (r rune, size int) 解析第一个p中的UTF8的编码字符，返回该字符的编码值与字节数。如果p是空的则返回(RuneError,0)，否则如果编码不正确，返回返回(RuneError,1) package main import ( \"fmt\" \"unicode/utf8\" ) func main() { b := []byte(\"Hello, 世界\") for len(b) \u003e 0 { r, size := utf8.DecodeRune(b) fmt.Printf(\"%c %v\\n\", r, size) b = b[size:] } } 输出： H 1 e 1 l 1 l 1 o 1 , 1 1 世 3 界 3 func DecodeRuneInString(s string) (r rune, size int) 与DecodeRune类似，但是输入时一个字符串，每次调用DecodeRuneInString都会返回一个rune还有rune的UTF-8编码的字节数size ","date":"2022-01-19","objectID":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/:2:1","tags":["go","gopl"],"title":"a.常用的go标准库","uri":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["go"],"content":"bytes、strings、strconv和unicode包 这四个包都是和字符串处理有关的包 ","date":"2022-01-19","objectID":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/:3:0","tags":["go","gopl"],"title":"a.常用的go标准库","uri":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["go"],"content":"fmt ","date":"2022-01-19","objectID":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/:4:0","tags":["go","gopl"],"title":"a.常用的go标准库","uri":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["go"],"content":"encode ","date":"2022-01-19","objectID":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/:5:0","tags":["go","gopl"],"title":"a.常用的go标准库","uri":"/a.%E5%B8%B8%E7%94%A8%E7%9A%84go%E6%A0%87%E5%87%86%E5%BA%93/"}]