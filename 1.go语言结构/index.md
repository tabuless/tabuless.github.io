# 1.go语言结构


## go语言概述

Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。

Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。

## go语言的关键字，预定义字，运算符

### 关键字

go语言的关键字有：

```go 
break      default       func     interface   select
case       defer         go       map         struct
chan       else          goto     package     switch
const      fallthrough   if       range       type
continue   for           import   return      var
```

### 预定义的字

还有大约30多个预定义的字,这些并不是关键字，可以被重新定义：

```go
内建常量: true false iota nil

内建类型: int int8 int16 int32 int64
          uint uint8 uint16 uint32 uint64 uintptr
          float32 float64 complex128 complex64
          bool byte rune string error

内建函数: make len cap new append copy close delete
          complex real imag
          panic recover		  
```

### 运算符

关于算术运算、逻辑运算和比较运算的二元运算符有：

```go
* / % &lt;&lt; &gt;&gt; &amp; &amp;^
&#43;(加号,字符串拼接符号) -(减号) | ^
== != &lt; &lt;= &gt; &gt;=
&amp;&amp;
||
对于前两行的运算符可以加个=,形成对应的简洁形式方便代码的书写，如&#43;=,-=,&gt;&gt;=
```

二元运算符有五种优先级。在同一个优先级而无括号的情况下，使用左优先结合规则。

关于比较的运算符有：

```go
== 	equal to
!= 	not equal to
&lt; 	less than
&lt;= 	less than or equal to
&gt; 	greater than
&gt;= 	greater than or equal to
```

上面的二元运算符中，有以下几个bit位操作运算符，前面4个操作运算符并不区分是有符号还是无符号数：

```go
&amp; 	与 AND
| 	或 OR
^ 	异或 XOR
&amp;^ 	位清空 (AND NOT)
&lt;&lt; 	左移(SHIFT LEFT)
&gt;&gt; 	右移(SHIFT RIGHT)
```

关于位清零：表达式`z = x &amp;^ y`结果，如果对应y中bit位为1的话，z的bit位为0，否则对应的bit位等于x相应的bit位的值。

左移运算`&lt;&lt;`用零填充右边空缺的bit位，无符号数的右移运算也是用0填充左边空缺的bit位，但是有符号数的右移运算会用符号位的值填充左边空缺的bit位。

一元运算符有：

```go
&#43;(正数)
-(负数)
!(逻辑非)
```



## go程序的基本格式

Go每句话末尾不需要加上分号，除非要在一行中将多个语句、声明隔开。

&gt; 在编译时，编译器会主动在一些特定的符号后添加分号（比如行末是：一个标识符、一个整数、浮点数、虚数、字符或字符串文字、关键字break、continue、fallthrough或return中的一个、运算符和分隔符&#43;&#43;、--、)、]或}中的一个），所以在哪里加分号合适取决于Go语言代码。
&gt; gofmt工具会将你的代码格式化为标准格式，并且go工具中的fmt子命令会自动对特定package下的所有.go源文件应用gofmt工具格式化。如果不指定package，则默认对当前目录下的源文件进行格式化。

一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。go程序一般按照下面的程序结构块顺序进行编写：

&#43; 包声明

  这行声明语句表示该文件是属于哪一个package

&#43; 引入包语句

  紧跟着包声明   是一系列import的package名，表示这个文件中引入的package，import声明必须跟在文件的package声明之后。  

  当我们import了一个包路径包含有多个单词的package时，比如apple/banana通常我们只需要用最后那个单词表示这个包就可以。所以当我们写banana.XXXX时，这个变量指向的是apple/banana包里的变量。

  如果包是自定义的包，则可以通过绝对路径或者相对路径进行导入即可。

&#43; 函数与表达式。

  在import语句之后，则是各种方法、变量、常量、类型的声明语句(分别用关键字func, var, const, type来进行定义)。这些内容的声明顺序并没有什么规定，但是建议遵循一定的规范。
  例：

```go
//包声明
package main
//引入包
import &#34;fmt&#34;
//函数
func main() {
	//表达式语句
    fmt.Println(&#34;Hello, 世界&#34;)
}
```

## package包

Go语言的代码是通过package来组织的，和其他语言的库或模块的概念类似，目的是为了支持模块化，封装，单独编译和代码的重用，一个package会包含一个或多个.go结束的源代码文件。每一个源文件都是以一个package xxx的声明语句开头的，这行声明语句表示该文件是属于哪一个package。

&gt; package main是一个比较特殊的package。这个package里会定义一个独立的程序，这个程序是可以运行的，而不是像其它package一样对应一个library。
&gt; 在main这个package里，main函数也是一个特殊的函数，是整个程序的入口。

每个包都有一个独立的名字空间，如`image.Decode`与`utf16.Decode`是不同的。

当不同的包之间有依赖关系，则包的初始化会按照包级变量声明出现顺序依次初始化，如果包中有多个.go文件，它们将按照发给编译器的顺序进行初始化，go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。比如，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化了 （包内的.go文件貌似是没有初始化顺序的）。

对于在包级别的变量，如果有初始化表达式则用表达式进行初始化，还有些没有初始化表达式的，例如一些表格数据初始化不是一个简单的赋值语句，可以用一个特殊的init初始化函数来简化初始化工作，每个文件都可以有多个init初始化函数。

## 作用域

一个声明语句将程序中的试题和一个名字关联，比如一个函数或者一个变量，声明语句的作用域是指源代码中可以有效使用这个名字的范围。

&gt; 作用域和生命周期的区别：
&gt;
&gt; 作用域对应的是一个源代码的文本区域，是一个编译时的属性，而一个变量的声明周期指的是程序运行时变量存在的有效时间段，在此事件区域内可以被程序的其他部分引用，是一个运行时概念。

go语言的语法块由`{}`所包含的一系列语句，语法块内部的名字无法被外部语法块访问，语法决定了内部声明的名字的作用域范围。

&#43; 最大的语法块为整个源代码，为全局语法块

  对于内置的类型，函数与常量（如`int`,`len`,`true`）在全局作用域，因此可以在整个程序中直接使用。  

&#43; 接着是每个包的包语法块

  在函数外部声明的名字处于包级作用域，可以在同一个包中的任何源文件访问

&#43; 然后是源文件级的作用域

  对于导入的包，例如导入的fmt包，则是对应源文件级的作用域，只能在当前文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。

&#43; 然后就是`for`,`if`,`switch`语句的语法块 ，每个`switch`或`select`的分支也有独立的语法块

  函数内部的变量则是局部作用域，仅仅函数内部才能访问。控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。

在函数中词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明。还有许多语法块是if或for等，控制流语句构造的。

下面的代码有三个不同的变量x，因为它们是定义在不同的词法域：

```go
func main() {
    x := &#34;hello!&#34;//第一个x
    for i := 0; i &lt; len(x); i&#43;&#43; {
        x := x[i]//第二个x,变量声明符号右边的x为第一个x
        if x != &#39;!&#39; {
            x := x &#43; &#39;A&#39; - &#39;a&#39;//第三个x,变量声明符号右边的x为第二个x
            fmt.Printf(&#34;%c&#34;, x) // &#34;HELLO&#34; (one letter per iteration)
        }
    }
}
```

隐含的规则：

1. for语句创建了两个词法域：

   一个隐式的部分是循环的初始化部分，条件测试部分和循环后的迭代部分，当然也包含循环体词法域。而花括弧包含的是显式的部分是for的循环体部分词法域

2. if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域

   if条件部分是一个词法域，括号内是另一个词法域

   switch条件部分为一个隐式词法域，然后每个是每个分支的词法域

一个典型的例子：

```go
var cwd string
func init() {
    cwd, err := os.Getwd() // compile error: unused: cwd
    if err != nil {
    	log.Fatalf(&#34;os.Getwd failed: %v&#34;, err)
    }
}
```

此时变量声明语句会屏蔽外部的cwd，使得外部的cwd没有被初始化，有许多方式可以避免出现类似潜在的问题,最直接的方法是通过单独声明err变量，来避免使用`:=`的简短声明方式

## go语言编码

go语言字符串，以及源文件使用的是utf-8编码，下面开始一步步介绍utf-8编码。

### ASCII码

ASCII大家应该比较熟，包含英文字母的大小写、数字、各种标点符号和设置控制符，但是只支持英语字母为语言的国家，不支持其他的字符。

### Unicode

 [unicode](http://unicode.org)收集了这个世界上所有的文书符号体系，每个符号都分配一个唯一的叫Unicode码点的无符号数字，Unicode码点对应Go语言中的rune整数类型。

我们可以将一个符文序列表示为一个int32序列。这种编码方式叫UTF-32或UCS-4，每个Unicode码点都使用同样的大小32bit来表示。但是对于有些对应的字符编号较小的字符不需要这么多位数，所以十分浪费存储，于是有了UTF8变长编码

### UTF8

UTF8是一个将Unicode码点编码为字节序列的变长编码。UTF8编码由Go语言之父[Ken Thompson](https://en.wikipedia.org/wiki/Ken_Thompson?oldformat=true)和Rob Pike共同发明的，现在已经是Unicode的标准。

UTF8编码使用1到4个字节来表示每个Unicode码：

| 格式                                | 范围           | 备注                    |      |
| ----------------------------------- | -------------- | ----------------------- | ---- |
| 0xxxxxxx                            | 0-127          | 与ASCII相同，兼容ASCII  |      |
| 110xxxxx 10xxxxxx                   | 128-2047       | 表示的值&lt;128的不予采用  |      |
| 1110xxxx 10xxxxxx 10xxxxxx          | 2048-65535     | 表示的值&lt;2048的不予采用 |      |
| 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx | 65536-0x10ffff | 其他的值不予采用        |      |

如果第一个字节的高位为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节，后续的每个高端bit都以10开头，以此类推。

UTF8的优点：

&#43; 完全兼容ASCII码
&#43; 是前缀编码，所以当从左向右解码时不会有任何歧义也并不需要向前查看（像GBK之类的编码，如果不知道起点位置则可能会出现歧义）
&#43; 没有任何字符的编码是其它字符编码的子串，或是其它编码序列的字串(因此搜索一个字符时只要搜索它的字节编码序列即可，不用担心前后的上下文会对搜索结果产生干扰)
&#43; UTF8编码的顺序和Unicode码点的顺序一致，因此可以直接排序UTF8编码序列
&#43; 因为没有嵌入的`NUL`(0)字节，可以很好地兼容那些使用`NUL`作为字符串结尾的编程语言

Go语言的源文件采用UTF8编码， 详见[unicode包](a.常用的go标准库.md##unicode包) 

每一个UTF8字符解码，不管是显式地调用utf8.DecodeRuneInString解码或是在range循环中隐式地解码，如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符`\uFFFD`，在印刷中这个符号通常是一个黑色六角或钻石形状，里面包含一个白色的问号`�`。 

UTF8字符串作为交互格式非常方便，但是在程序内部采用rune序列可能更方便，因为rune大小一致，支持数组索引和方便切割。因此string接受到[]rune的类型转换，可以将一个UTF8编码的字符串解码为Unicode字符序列，详见 [2. go语言基础语法.md](2. go语言基础语法.md#####字符串字面量（String Literals）) 


